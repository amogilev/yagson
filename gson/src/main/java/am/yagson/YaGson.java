package am.yagson;

import am.yagson.refs.References;
import am.yagson.refs.ReferencesPolicy;
import am.yagson.types.TypeInfoPolicy;
import com.google.gson.*;
import com.google.gson.internal.Excluder;

import java.lang.reflect.Type;
import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 * The main class for using YaGson. Along with {@link YaGsonBuilder}, it provides similar
 * creation and usage patterns as the basic {@link Gson}, but the references emitting and
 * the type info emitting are enabled by default. See {@link References#defaultPolicy()} and
 * {@link TypeInfoPolicy#defaultPolicy()} for the default YaGson's settings.
 * <p/>
 * If any non-default features are required, use {@link YaGsonBuilder} to create {@link YaGson}
 * instance.
 */
public class YaGson extends Gson {

    /**
     * Constructs a Gson object with default configuration. The default configuration has the
     * following settings:
     * <ul>
     *   <li>By default, YaGson's detects circular references and emits them as links, see
     *   {@link ReferencesPolicy#CIRCULAR_ONLY}. Use {@link YaGsonBuilder#setReferencesPolicy(ReferencesPolicy)}
     *   to change it if necessary.</li>
     *   <li>By default, the type information is emitted when the actual types would be lost otherwise,
     *   i.e. when the known de-serialization type is less specific than the actual class of an abject
     *   or its part being serialized; the type information is emitted as either preceding {@literal @vtype}
     *   fields (where possible, i.e. for fields), or as {@literal @type/@value} wrappers;
     *   see {@link TypeInfoPolicy#EMIT_WRAPPERS_OR_VTYPES}. Use
     *   {@link YaGsonBuilder#setTypeInfoPolicy(TypeInfoPolicy)} to change it if necessary.</li>
     *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This
     *   means that all the unneeded white-space is removed. You can change this behavior with
     *   {@link GsonBuilder#setPrettyPrinting()}. </li>
     *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are
     *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its
     *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values
     *   by setting {@link GsonBuilder#serializeNulls()}.</li>
     *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},
     *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},
     *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer
     *   to change the default representation, you can do so by registering a type adapter through
     *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>
     *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format
     *   ignores the millisecond portion of the date during serialization. You can change
     *   this by invoking {@link GsonBuilder#setDateFormat(int)} or
     *   {@link GsonBuilder#setDateFormat(String)}. </li>
     *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.
     *   You can enable Gson to serialize/deserialize only those fields marked with this annotation
     *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>
     *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You
     *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>
     *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class
     *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in
     *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can
     *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>
     *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from
     *   consideration for serialization and deserialization. You can change this behavior through
     *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>
     * </ul>
     */
    public YaGson() {
        super(Excluder.DEFAULT.forReferencesPolicy(References.defaultPolicy()),
                FieldNamingPolicy.IDENTITY,
                Collections.<Type, InstanceCreator<?>>emptyMap(), false,
                TypeInfoPolicy.defaultPolicy().isEnabled() ? true : false,
                DEFAULT_JSON_NON_EXECUTABLE,
                true, false, false, LongSerializationPolicy.DEFAULT,
                Collections.<TypeAdapterFactory>emptyList(),
                References.defaultPolicy(), TypeInfoPolicy.defaultPolicy());
    }

    protected YaGson(Excluder excluder, FieldNamingStrategy fieldNamingPolicy,
          Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
          boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
          boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,
          LongSerializationPolicy longSerializationPolicy, List<TypeAdapterFactory> typeAdapterFactories,
          ReferencesPolicy referencesPolicy, TypeInfoPolicy typeInfoPolicy) {
        super(excluder, fieldNamingPolicy, instanceCreators, serializeNulls, complexMapKeySerialization,
                generateNonExecutableGson, htmlSafe, prettyPrinting, serializeSpecialFloatingPointValues,
                longSerializationPolicy, typeAdapterFactories, referencesPolicy, typeInfoPolicy);
    }
}
